# 2020-05-13 Study

2020-05-13 수요일 수업 내용 

### 복습

**얕은 카피** - 메모리 부분만 공유한다 (카피된 두 개체가 서로 같은 주소를 가지고 있다.) 즉, A를 변경하면 B도 따라서 변경된다.

```py
a = [1,2,3]
b = a
id(a), id(b)    # 주소값이 같다.
```

**깊은 카피** - 얕은 카피와 반대. 값은 같게 생성되지만 메모리부분이 다르다. 즉, 서로 다른 주소를 가지고 있어 a가 변경되도 b는 변경이 되질 않는다.

```py
import copy

b = copy.deepcopy(a) 

# 또는

b = a[:]

id(a), id(b)    # 주소값이 다르다.
```

기본적으로 카피를 사용하려면 **import copy**를 해서 copy 라이브러리를 불러와야 한다.

> 참고 [카피에 대해서 보러가기](https://wikidocs.net/16038)

### 문자열 표현

따옴표로 모든 문자열을 표현한다.

```py
a = 'hello'
b = "hello"         # 첫 시작 따옴표와 마지막 따옴표는 매핑되어야 에러가 나질 않는다.

print("원주율은 " + 3.141592)   # 에러o
print("원주율은"+"3.141592")    # 에러x
```

### 표현식 문자열 실행 함수 eval()

```py
eval('3+15/2')      # 10.5
eval('4*3%5')       # 2
eval('3* -2 ** 3')  # -24
```

### 키워드 확인

```py
import keyword
print(keyword.kwlist)
```

### 섭씨 온도와 화씨 온도의 관계 및 변환

```py
celsius = 37
fahrenhite = celsius * 9/5 + 32                     # 화씨 온도로 변환
print('섭씨: ', celsius, ',', '화씨: ', fahrenhite)
```

### 문자열의 부분 문자열 참조 방식

``str[start:end:step]`` 문자열 str에서 start 첨자에서 end-1까지의 문자열을 반환. step은 칸 수를 의미.

```py
'python'[1:5]   # 'ytho'
'python'[0:6]   # 'python'
'python'[0:-1]  # 'pytho'
'python'[0:6:2] # 'pto'
```

### 문자열의 최대 최소

```py
min('python')       # 'h'
max('python')       # 'y'
min('3259')         # '2'
max('3259')         # '9'
min('java','jaba')  # jaba
```

### count(), join()

count() : 부분 문자열 출현 횟수를 반환

```py
str = '단순한 것이 복잡한 것보다 낫다.'
str.count('복잡')           # 1
str.count('것')             # 2
```

join() : 문자와 문자 사이에 문자열을 삽입

```py
num = '12345'
'->'.join(num)              # '1->2->3->4->5'
```

### 문자열 찾기

find()와 index()

```py
str = '자바 C 파이썬 코틀린'
str.find('자바')            # 0
str.index('자바')           # 0
str.find('파이')            # 5
str.index('파이썬')         # 5
str.find('C++')             # -1 ; 없을 경우에는 -1 값 반환
str.index('C++')            # 에러 출력
```

### 문자열 나누기(중요!)

```py
str = '사과 배 복숭아 딸기 포도'
str.split()                     # ['사과', '배', '복숭아', '딸기', '포도']
```

### center()

폭을 지정하고 중앙에 문자열을 배치하는 메소드

```py
' 파이썬 강좌 '.center(30, '*')         # '********** 파이썬 강좌 ***********'
```

### strip()

문자열 앞 뒤의 특정 문자들을 제거하는 strip() 메소드

```py
'  python  '.lstrip()           # 'python  '
'  python  '.rstrip()           # '  python'
'  python  '.strip()            # 'python'
'  ***python--  '.strip('* -')  # 'python'
```
### 비트 연산

비트 논리곱 &
비트 논리합 |
비트 배타적 논리합 ^

```py
m, n = 0, 0
'{} {} {} {} {}'.format(m, n, m&n, m|n, m^n)    # '0 0 0 0 0'

m, n = 0, 1
'{} {} {} {} {}'.format(m, n, m&n, m|n, m^n)    # '0 1 0 1 1'

m, n = 1, 0
'{} {} {} {} {}'.format(m, n, m&n, m|n, m^n)    # '1 0 0 1 1'

m, n = 1, 1
'{} {} {} {} {}'.format(m, n, m&n, m|n, m^n)    # '1 1 1 1 0'
```

### 비트 논리곱 &로 특정 비트의 값 알아 내기

이 행위를 보통 마스킹(making)하다 라고 한다.

```py
a = int(input('정수 하나를 입력하세요 >> '))
mask = 0b1111   # 0xf도 가능
print('정수 {0} 2진수로는 {0:b}'.format(a))
print('가장 오른쪽 4비트: {0:04b} 정수로는 {0}'.format(a & mask))
```

```
정수 하나를 입력하세요 >> 195
정수 195 2진수로는 11000011
가장 오른쪽 4비트: 0011 정수로는 3
```

### 비트 배타적 논리합 ^

**익스클루시브 or**라고 한다.

보통 보안쪽에서 많이 사용한다.


### 비트 이동 연산

``>>``와 ``<<``를 사용.

```py
a = 0b00010111
print('10진수 {0:3d}, 2진수 {0:08b}'.format(a))         # 10진수 23, 2진수 00010111

print('10진수 {0:3d}, 2진수 {0:08b}'.format(a >> 1))         # 10진수 11, 2진수 00001011

print('10진수 {0:3d}, 2진수 {0:08b}'.format(a // 2))         # 10진수 11, 2진수 00001011

print('10진수 {0:3d}, 2진수 {0:08b}'.format(a >> 2))         # 10진수 5, 2진수 00000101

print('10진수 {0:3d}, 2진수 {0:08b}'.format(a // 2**2))         # 10진수 5, 2진수 00000101
```