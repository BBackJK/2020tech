# 2020-05-25 Study

2020-05-25 월요일 수업 내용  

## 복습

### 상속의 중요성

- 방대한 코드로 구성된 프로그램을 개발하는 과정에서 파악
- 레퍼런스 업캐스팅
- 메소드 오버라이딩
- 신규로 프로그램을 추가할 때 ; 기존 작성된 코드를 수정하지 않아도 됨, 수정 시에도 파급 영향을 최소화할 수 있음.

> 레퍼런스 ;변수를 의미(stack영역에 별도로 존재) 즉, 객체 생성할 때 선언한 변수는 heap안에 stack영역에 생성 클래스 주소를 가리키게 된다. 참고 [java heap memory](https://yaboong.github.io/java/2018/05/26/java-memory-management/)



### 레퍼런스 업캐스팅

- 서브 클래스의 객체는...

슈퍼 클래스의 멤버를 모두 가지고 있음.  
슈퍼 클래스의 객체로 취급할 수 있음.

> 상속 관계에서 A를 상속받은 B에 대해서 ``B는 A다``라고 할 수 있다. ex) 사람은 생물이다.

- 업캐스팅이란?

서브 클래스 객체를 슈퍼 클래스 타입으로 타입 변환


```java
class Person {
    String name;
    String id;

    public Person(String nane) {
        this.name = name;
    }
}

class Student extends Person {
    String grade;
    Srtring ...;

    public Student(String name) {
        super(name);
    }
}

public class Upcasting {
    public static void main(String[] args) {
        Person p;
        Student s = new Student('홍길동');

        p = s;  // 업캐스팅

        System.out.println(p.name);  // 오류 없음 ; 홍길동

        p.grade = "A"   // 컴파일 오류
    }
}
```

### 다운캐스팅

```java
public class DownCasting {
    Person p = new Student('홍길동');
    Student s;

    s = (Student)p                  // 다운 캐스팅

    System.out.println(s.name);     // 홍길동
    s.grade = "A"                   // 오류 없음
}
```

### instanceof 사용

```java
class Person {};
class Student extends Person {};
class Researcher extends Student {};
class Professor extends Researcher {};

public class instanceOfEx {

    static void print(Person p) {
        if(p instanceof Person)
            System.out.println("Person:");
        if(p instanceof Student)
            System.out.println("Student:");
        if(p instanceof Researcher)
            System.out.println("Researcher:");
        if(p instanceof Professor)
            System.out.println("Professor:");
        System.out.println();
    }

    public static void main(String[] args) {
        System.out.print("new Student() -> \t"); print(new Student());
        System.out.print("new Researcher() -> \t"); print(new Researcher());
        System.out.print("new Professor() -> \t"); print(new Professor());
    }
}
```

### 메소드 오버라이딩

- 수퍼클래스의 메소드를 서브 클래스에서 재정의  

슈퍼 클래스 메소드의 이름, 매개변수 타입 및 개수, 리턴 타입 등 모든 것 동일하게 작성

- 메소드 무시하기, 덮어쓰기로 번역되기도 함  

- 동적 바인딩 발생  

서브 클래스에 오버라이딩된 메소드가 무조건 실행되는 동적 바인딩

### 오버라이딩의 목적, 다형성 실현

- 오버라이딩

슈퍼 클래스에 선언된 메소드를, 각 서브 클래스들이 자신만의 내용으로 새로 구현하는 기능  

상속을 통해 ``하나의 인터페이스(같은 이름)에 서로 다른 내용 구현``이라는 객체 지향의 다형성 실현

ex) ``Line`` 클래스의 ``draw()``는 선을 그리고, ``Circle``클래스의 ``draw()``는 원을 그리고, ``Rect`` 클래스의 ``draw()``는 사각형을 그리고..

- 오버라이딩은 실행 시간 다형성 실현

동적 바인딩을 통해 실행 중에 다형성 실현  

> 오버로딩은 컴파일 타임 다형성 실현


```java
class Shape {
    public Shape next;
    public Shape() { next = null;}

    public void draw() {
        System.out.println("Shape");
    }
}

class Line extends Shape {
    public void draw() {    // 메소드 오버라이딩
        System.out.println("Line");
    }
}

class Rect extends Shape {
    public void draw() {    // 메소드 오버 라이딩
        System.out.println("Rect");
    }
}

class Circle extends Shape {
    public void draw() {
        System.out.println("Circle");
    }
}

public class MethodOverridingEx {
    static void paint(Shape p) {
        p.draw();   // p가 가리키는 객체 내에 오버라이딩된 draw() 호출;
                    // 동적 바인딩    
    }

    public static void main(String[] args) {
        Line line = new Line();

        paint(line);                // Line
        paint(new Shape());         // Shape
        paint(new Line());          // Line
        paint(new Rect());          // Rect
        paint(new Circle());        // Circle
    }
}
```

### 오버라이딩과 super 키워드

- super는 슈퍼 클래스의 멤버를 접근할 때 사용되는 레퍼런스
- 서브 클래스에서만 사용
- 슈퍼 클래스의 메소드 호출
- 컴파일러는 super의 접근을 **정적 바인딩**으로 처리


### 오버라이딩 vs 오버로딩


비교요소 | 메소드 오버로딩 | 메소드 오버라이딩
---|:---:|---:
**선언** | 같은 클래스나 상속 관계에서 동일한 이름의 메소드 중복 지정 | 서브 클래스에서 슈퍼 클래스에 있는 메소드와 동일한 이름의 메소드 재작성
**관계** | 동일한 클래스 내 혹은 상속 관계 | 상속 관계
**목적** | 이름이 같은 여러 개의 메소드를 중복 작성하여 사용의 편리성 향상. **다형성 실현** | 슈퍼 클래스에 구현된 메소드를 무시하고, 서브 클래스에서 새로운 기능의 메소드를 재정의하고자 함. **다형성 실현**
**조건** | 메소드 이름은 반드시 동일하고, 매개변수 타입이나 개수가 달라야 성립 | 메소드의 이름, 매개변수 타입과 개수, 리턴 타입이 모두 동일하여야 성립.
**바인딩** | 정적 바인딩. 호출될 메소드는 컴파일 시에 결정 | 동적 바인딩. 실행 시간에 오버라이딩된 메소드를 찾아 호출

### 추상 메소드와 추상 클래스

- 추상 메소드

선언 되어 있으나 구현되어 있지 않은 메소드, abstract로 선언  

```java
public abstract String getName() {};
public abstract void setName(String name) {};
```

추상 메소드는 서브 클래스에서 오버라이딩하여 구현해야 함.

- 추상 클래스(abstract class)의 2 종류

추상 메소드를 하나라도 가진 클래스 ; 클래스 앞에 반드시 abstract라고 선언해야 한다.  

추상 메소드가 하나도 없지만 abstract로 선언된 클래스

> 추상 클래스는 객체를 생성할 수 없다.

```java
abstract class Calculator {
    public abstract int add(int a, int b);
    public abstract int subtract(int a, int b);
    public abstract double average(int[] a);
}
```

